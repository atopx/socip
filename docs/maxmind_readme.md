# 基于MaxMind DB构建高效IP查询库

> 1. 基于 MaxMind DB 2.0版本
> 2. 官方网站: http://maxmind.github.io/MaxMind-DB/

## 研究目的

1. 可构建用于快速查询IP的Geo信息或其他描述信息的离线DB库。
2. 基于构建的DB库可用于web接口服务，相较于做索引后PG数据库快100倍以上(连续查询效率相比PG高出更多倍)
3. 基于构建的DB库可用于Logstash-filter-geoip插件，快速对IP相关信息进行描述

## 基础知识

### IP(Internet Protocol): 互联网协议 (网际互连协议)

> 1. 在Open System Interconnection中属于网络层协议中的一部分
>
> 2. 解决大规模的网络互联，在OSI模型中对其下层和上层起到解偶作用

- IP地址: 网际互连协议中的一部分，为具有互联网协议的设备分配唯一地址

  > 对应中国公民的身份证号，物流地址，手机号等等

- IPv4：一个32位的二进制数，被分割为4个8位二进制数(4个字节)

  > 1. 通常用点分十进制表示: 1.1.1.1, 172.30.0.168, 1.198.22.228
  > 2. 00000001 00000001 00000001 00000001 = 1.1.1.1 = 16843009

### 端模式（Endian）

如果将一个32位的整数0x12345678存放到一个整型变量（int）中，这个整型变量采用大端或者小端模式在内存中的存储由下表所示。

| 地址偏移 | 大端模式  | 小端模式  |
| :------: | :-------: | :-------: |
|   0x00   | 12（OP0） | 78（OP3） |
|   0x01   | 34（OP1） | 56（OP2） |
|   0x02   | 56（OP2） | 34（OP1） |
|   0x03   | 78（OP3） | 12（OP0） |

> 总结：
>  1. 大端方式将高位存放在低地址, 小端方式将高位存放在高地址
>  2. 大端方式进行数据存放符合人类的正常思维，而采用小端方式进行数据存放利于计算机处理

## 内容概述

> MaxMind DB是一种数据库格式的文件，它使用<u>**高效的二叉搜索树**</u>把IPv4和IPv6记录到数据库。
>
> 原文链接：[MaxMind DB File Format Specification](http://maxmind.github.io/MaxMind-DB/)
1. 二叉搜索树: 每个层级对应于128位的中的一位,(IPv4长度为32，IPv6地址长度为128), 位于数据库最上面
2. 数据层: 返回给客户端的具体数据，映射到键值对，key=IP，该部分可以理解为的value, 位于数据库的中间
3. 数据库元数据: 数据库文件的描述信息，位于数据库最下方


![构造示例图](./images/image-20200612160610574.png "MaxMind DB构造示例图")


### 1. 元数据层

> 数据库文件本身的描述信息和搜索树的信息，位于数据库最下方，由`b'\xab\xcd\xefMaxMind.com'`分割数据层

#### node_count（必须）

- 节点数量：无符号的`32-bit` , 记录搜索树中的节点数量

#### record_size（必须）

- 位大小：无符号的`16-bit` , 记录搜索树中的位大小，每个`node`都有两个记录(指针)

#### ip_version（必须）

- IP版本：无符号的`16-bit` ，只能是`4`或`6`。

#### database_type（必须）

- string类型，需要记录的数据类型的命名(自定义，比如`SocGeoIP`)

#### languages（可选）

- string array类型，内容都是区域代码，建议的字段包含数据记录中所有语言，如`['en', 'cn']`

#### binary_format_major_version(可选)

- 无符号的`16-bit` 整数，数据库的主要版本号。

#### binary_format_minor_version（可选）

- 无符号的`16-bit` 整数， 数据库的次要版本号

#### build_epoch（可选）

- 无符号的`64-bit`整数, *Unix epoch*类型的时间戳（1970.01.01到现在所经过的秒数）

#### description（可选）

> 强烈建议开发者定义至少一种语言的描述。

- map(object、dict) 类型，对数据库的描述，如`{'cn': '赛欧思IP地理信息离线数据库'}`

#### 计算搜索树大小

```
(record_size * 2) / 8 * node_count
```
> 搜索树的结束标志着数据段的开始



### 2. 数据层

> 数据层位于整个文件的中层位置，于上面搜索树层使用16位的null值分割，与下面元数据层使用`b'\xab\xcd\xefMaxMind.com'`分割
>
> 作用是对IP的描述信息或者业务数据的存储



### 3. 二叉搜索树层

> 搜索树的每个层级对应于128位的中的一位,(IPv4长度为32，IPv6地址长度为128), 位于数据库最上面
>
> 通过二进制的整型IP做索引数据，由 node_count 个节点组成，每个节点有两个记录(指向文件中地址的指针)
>
> 为方便描述和解释，下文中指针以`p`表示, 所指向的值以`*p`表示

#### 节点布局

record_size的值根据数据库的规模相关，在单个数据库节点内，记录的大小始终保持相同，每条记录的长度固定在`24-bit` 到 `128-bit`之间，实际取决于`node_count`的数量， 指针以以大端二进制格式存储（最高有效字节在前）, `*p对应node号`

- 24 bits(小型数据库)，`6 bytes/node`

  ```
  | <------------- node --------------->|
  | 23 .. 0          |          23 .. 0 |
  ```
  
- 28 bits(小型数据库)，`7 bytes/node`

  ```
  | <------------- node --------------->|
  | 23 .. 0 | 27..24 | 27..24 | 23 .. 0 |
  ```

- 32 bits(小型数据库)，`8 bytes/node`

  ```
  | <------------- node --------------->|
  | 31 .. 0          |          31 .. 0 |
  ```


#### 搜索算法详解

> 搜索IPv4(32 bit)为例, IPv6(128 bit)同理
>
> 最左边的点对应于在搜索树的第一个节点, 对于每一位(bit)，值为0表示我们选择节点中的左记录， 值为1表示选择节点中的右记录

比较当前选中的记录值(*p)和实际节点数

1. *p < node_count: 取记录的节点继续搜索

2. *p = node_count: 表示搜索的IP不在库中

3. *p > node_count: 表示此时p指向数据层，找到对应的数据

当第三种情况时，指针的值需要从数据段的开始计算的，因此需要先计算数据端的偏移量`offset`

```
data_offset = ( *p - node_count ) - 16
```

> 搜索树和数据层的分隔符大小是16字节的null

#### 小案例：

```
# 指针大小
record_size = 24
# 节点数量
node_count = 1000
# 每节点大小
node_size = 24 * 2 bit = 6 bytes
tree_size = node_size * node_count = 6000 bytes
```

当树中的记录包含 <1000 的数值时, 此时p指向的记录是另一个节点(pn), 继续查找pn, 如果记录的值为x(x >1016), 可以确定它指向数据层，那么此时x到数据层的`offset = x - 1016`)

> 如果要确定此偏移量真正指向的文件中的位置: 
  ```
  $offset_in_file = (x - node_count) + $tree_size + 16
  ```


官网还包含其他内容，比如数据端类型序号和长度的定义，字段的格式，有效载荷的大小，数据段大小限制等等，有兴趣的同学可以自行研究

